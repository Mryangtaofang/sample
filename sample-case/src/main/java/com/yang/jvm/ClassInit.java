package com.yang.jvm;

/***
 * # 类加载机制
 * 首先, 我们来看一下类的生命周期, 如下图所示。
 *        
 *  加载   -> 验证  -> 准备  -> 解析  -> 初始化 -> 使用 -> 销毁
 *        |------连接------|
 *        
 * 其中验证、准备、解析3个阶段统称为连接。
 * 加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的, 而解析阶段则不一定, 
 * 它在某些情况下可在初始化阶段之后运行,这是为了支持Java语言的运行时绑定(也叫后期绑定或动态绑定)
 */


/**
 * # 加载
 * 加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。
 * 注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），
 * 也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。
 */


/**
 * # 验证
 * 这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
 * 
 * # 准备
 * 准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。
 * 注意这里所说的初始值概念，比如一个类变量定义为：
 * public static int v = 8080;
 * 
 * 实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的putstatic指令是程序被编译后，存放于类构造器<client>方法之中，这里我们后面会解释。
 * 但是注意如果声明为：
 * public static final int v = 8080;
 * 
 * 在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。
 */


/**
 * # 解析
 * 解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的：
 *
 * CONSTANT_Class_info
 * CONSTANT_Field_info
 * CONSTANT_Method_info
 * 等类型的常量。
 *
 * 下面我们解释一下符号引用和直接引用的概念：
 *
 * 符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。
 * 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。
 */


/**
 * # 初始化
 * 一、对于初始化阶段, 虚拟机规范严格规定了有且只有以下5种情况, 必须立即对类进行初始化:
 *
 * 1):遇到new、getstatic、putstatic、invokestatic这4条字节码指令时, 如果类没有进行过初始化,
 *    则需要先触发其初始化。生成这4条指令的常见场景是: 使用new关键字实例化对象时, 读取或设置一个类的静态字段(被final修饰、已在编译期将结果放入常量池的静态字段除外)时, 调用一个类的静态方法时。
 *
 * 2):使用java.lang.reflect包的方法对类进行反射调用时, 如果类没有进行过初始化, 则需要先触发其初始化。
 *
 * 3):当初始化一个类时, 如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化。
 *
 * 4):当虚拟机启动时, 用户需要指定一个要执行的主类, 虚拟机会先初始化这个主类。
 *
 * 5):当使用 JDK1.7 的动态语言支持时, 如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄,
 * 	      并且该方法句柄所对应的类没有进行过初始化, 则需要先触发其初始化。
 * 
 * 二、注意以下几种情况不会执行类初始化：
 * 
 * 1):通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
 * 
 * 2):定义对象数组，不会触发该类的初始化。
 * 
 * 3):常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
 * 
 * 4):通过类名获取Class对象，不会触发类的初始化。
 * 
 * 5):通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
 * 
 * 6):通过ClassLoader默认的loadClass方法，也不会触发初始化动作。
 */
public class ClassInit {
	
	public static void main(String[] args) {
//		case1();
//		case2();
		case3();
	}
	
	
	/**
	 * 使用类的final类型的静态变量,不会造成类的初始化
	 * (常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类)
	 */
	public static void case1(){
		System.out.println(SubClassInitProcess.final_static_string);
		System.out.println(SubClassInitProcess.sub_final_static_string);
	}
	
	/** 通过子类引用父类的静态变量，只会初始化父类  */
	public static void case2(){
		System.out.println(SubClassInitProcess.static_string);
	}
	
	/** 在初始化子类之前，一定会先初始化父类 */
	public static void case3(){
		System.out.println(SubClassInitProcess.sub_static_string);
	}
}
